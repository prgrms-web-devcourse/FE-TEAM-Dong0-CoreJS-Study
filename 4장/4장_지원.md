# Callback function

## :question: Callback function?

> 다른 코드의 인자로 넘겨주는 함수

## 제어권

:computer: **예시코드**

```javascript
let count = 0
let callbackFunction = () => {
  console.log(count)
  if (++count > 4) clearInterval(timer)
}
let timer = setInterval(callbackFunction, 500)
```

- `callbackFunction()` in 사용자 함수
  - 주체 : 사용자
  - 제어권 : 사용자
- `callbackFunction()` in setInteraval(cb, 300)
  - 주체 : setInterval
  - 제어권 : setInterval

### 인자

```javascript
const arr = [1, 2, 3, 4, 5]
const arrAdd1 = arr.map((value, index) => {
  return value + 3
})
// arrAdd1 : [4,5,6,7,8]
const arrAdd2 = arr.map((index, value) => {
  return value + 3
})
// arrAdd2 : [3,4,5,6,7]
```

- 호출하는 주체가 되는 함수에서 해당 콜백함수의 인자 순서가 정해져 있기 때문에 이름이 같더라도 서순이 바뀌면 안된다.

### this

- 기본적으로 callback함수를 제어권이 있는 함수에서 아무 처리 없이 호출한다면 callback 내부의 this는 전역 객체가 된다. 그러나 제어권을 가진 함수에서 별도의 할당 (call/apply)등을 통해 넘겨받은 thisArg를 this binding한 채로 사용할 수 있다.
- `addEventListener`는 해당 메소드를 호출한 HTML element를 call 메서드를 통해 this binding하게 된다.

## this에 다른값 바인딩

```javascript
// traditional
// 별도의 변수, 클로저 사용
const obj1 = {
  name: 'obj1',
  func: function () {
    const self = this
    return function () {
      console.log(self.name)
    }
  },
}

const obj = {
  name: 'obj',
  func: function () {
    console.log(this.name)
  },
}

const callback = obj1.func() // 클로저 ( {self:obj1} / function(){ console.log(self.name) } )
setTimeout(callback, 1000)
setTimeout(obj1.func().bind(obj), 1000)
```

별도의 변수 `self`에 this를 담아서 클로저로 사용하는 방식은

1. 실제 this를 사용하는 것이 아니고
2. 작성도 번거로움

따라서 bind를 통해 callback함수의 this를 원하는 객체로 할당하는 보완방법이 있다.

## 비동기 제어와 Callback Hell

### Callback hell (콜백 지옥)

콜백함수를 익명 함수로 전달하는 과정이 반복되어 코드의 depth가 굉장히 깊어지는 현상

- 코드의 가독성이 안좋음
- 코드 수정또한 어려움

### 해결책

1. Promise (ES6)
2. Generator (ES6)
3. async / await(ES8)

- 2depth => Promise
