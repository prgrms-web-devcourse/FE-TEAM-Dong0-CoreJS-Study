# 3. this

- JS는 함수와 메서드의 구분이 느슨함 => `this`로 둘을 구분 가능

## 상황에 따라 달라지는 this

### 전역의 this

- this는 실행 컨텍스트가 생성될 때 함께 결정 === 함수를 호출할 때 결정, 호출한 주체
- 전역 공간에서 this는 전역 객체를 가리킴
  - 런타임 환경에 따라 전역 객체가 다르다. (브라우저 => window, Node.js => global)
  - 전역 공간에서 선언한 변수는 전역 객체의 프로퍼티가 됨
    - JS에서 모든 변수는 *특정 객체의 프로퍼티*로서 동작
- 전역 변수(`var ~`)와 전역 객체의 프로퍼티(`window.~`)
  - 호이스팅 및 configurable에서 차이 => window의 프로퍼티는 delete가 됨

### 함수와 메서드

- 둘 다 어떤 동작 수행, 구분 기준은 **독립성** => 이름 앞에 점(.) 유무
  - 함수는 자체가 기능 수행, 메서드는 자신의 대상 객체에 관한 동작 수행
- 함수에서 this는 전역 객체, 메서드에서 this는 마지막 점 앞에 명시된 객체

```javascript
var obj1 = {
  outer: function () {
    console.log(this); // 1
    var innerFunc = function () {
      console.log(this); // 2, 3
    };
    innerFunc();

    var obj2 = {
      innerMethod: innerFunc,
    };
    obj2.innerMethod();

    var self = this;
    var innerFuncWithSelf = function () {
      console.log(self); // 4, this 우회
    };
    innerFuncWithSelf(); // 메서드의 내부 함수
  },
};

obj1.outer();

// obj1, {outer: ƒ} => outer 메서드 앞에 obj1
// Window 객체 => innerFunc 함수로서 호출됨
// obj2, {innerMethod: ƒ} => innerMethod 앞의 obj2
// obj1, {outer: ƒ} => 상위 스코프의 this 미리 저장
```

### 화살표 함수(ES6+)

- 실행 컨텍스트를 생성할 때 this 바인딩을 하지 않음 => 상위 스코프 this 그대로 활용
  - 예를 들면 스코프 체인을 타고 올라가서 전역 객체 Window 바인딩

```javascript
// callback으로 함수 선언식
document.body.innerHTML += "<button id='a'>클릭</button>";
document.body.querySelector("#a").addEventListener("click", function (event) {
  console.log(this); // this가 addEventListener 앞의 객체에 바인딩, button element
  console.log(this === document.body.querySelector("#a")); // true
});

// callback으로 화살표 함수
document.body.innerHTML += "<button id='b'>bbbb</button>";
document.body.querySelector("#b").addEventListener("click", (event) => {
  console.log(this); // this 바인딩 안됨, Window 출력
});
```

### 생성자 함수의 this

- JS에서 new와 함께 함수 호출하면 생성자 함수
  - 생성자 함수를 호출하면 생성자의 프로토타입 프로퍼티를 참조하는 `__proto__`라는 프로퍼티가 있는 객체(인스턴스)를 만듦
  - 공통 속성 및 개성을 객체(this)에 부여

## 명시적 this 바인딩
