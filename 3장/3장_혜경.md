## this

### 상황에 따라 달라지는 this

- this는 실행 컨텍스트가 생성될 때(함수를 호출할 때) 함께 결정된다.
  => this는 `함수를 호출`할 때 결정된다

### 전역공간에서 this

- this는 전역 객체를 가리킨다.
- 전역객체
  - 브라우저 환경 : window
  - Node.js 환경 : global

* 전역 공간에서만 발생하는 특이한 성질
  - 전역 변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로도 할당한다 (변수이면서 객체의 프로퍼티임!)
  - 자바스크립트의 모든 변수는 특정 객체의 프로퍼티로서 동작함!
  - 사용자가 var 연산자를 이용해 변수를 선언하더라도 실제 자바스크립트 엔진은 어떤 특정 객체의 프로퍼티로 인식함
  - 여기서 특정 객체는 실행 컨텍스트의 LexicalEnvironment
  - 이 때, 전역 컨텍스트의 경우에는 L.E는 전역객체를 그대로 참조한다

=> 전역 공간에서는 var로 변수를 선언하는 대신 window의 프로퍼티에 직접 할당하더라도 결과적으로 var로 선언한 것과 똑같이 동작함!
=> 단, `delete`의 경우는 아님!

🤔 왜 안 돼?
처음부터 전역객체의 프로퍼티로 할당한 경우에는 삭제가 되나, 전역변수로 선언한 경우에는 삭제가 되지 않는다
=> `전역 변수를 선언`하면 자바스크립트 엔진이 이를 자동으로 전역객체의 프로터피로 할당하면서 추가적으로 해당 프로퍼티의 configurable 속성(변경 및 삭제 가능성)을 `false`로 정의하는 것이다

=> var로 선언한 전역변수와 전역객체의 프로퍼티는 호이스팅 여부 및 configurable 여부에서 차이를 보인다.

### 메서드로서 호출할 때 그 메서드 내부에서의 this

함수와 메서드는 `독립성`에 차이가 있다
`함수` : 그 자체로 독립적인 기능을 수행
`메서드` : 자신을 호출한 대상 객체에 관한 동작을 수행

=> 둘은 함수 앞에 점(.)이 있는지 여부만으로 간단하게 구분할 ㅅ ㅜ있다
앞에 점이 없으면 함수로서 호출한 것이고, `함수앞에 .이 있거나 대괄호 표기법`에 따른 경우도 메서드로서 호출한 것

=> 함수를 호출할 때 함수 이름 앞에 객체가 명시되어있는 경우에는 메서드로 호출한 것이고, 그렇지 않은 모든 경우에는 함수로 호출한 것

메서드 내부에서의 this

- this에는 호출한 주제에 대한 정보가 담긴다.
- 메서드로 호출한 경우 호출 주체는 바로 `함수명 앞의 객체`이다.

### 함수로서 호출할 때 그 함수 내부에서의 this

1. 함수 내부에서의 this
   함수로서 호출하는 경우에는 호출 주체를 명시하지 않고, 개발자가 코드에 직접 관여하여 실행한 것이기 때문에 호출 주체의 정보를 알 수 없다.
   함수에서의 this는 전역객체를 가리킨다

2. 메서드 내부함수에서의 this

   함수를 실행하는 당시의 주변환경은 중요하지 않고, 오로지 `해당 함수를 호출하는 구문 앞에 점 또는 대괄호 표기가 있는지 없는지`가 관건임

3. 메서드 내부 함수에서 this를 우회하는 방법
   보통 self라는 변수명을 이용해서 상위 스코프의 this를 저장해서 내부 함수에서 활용함

4. this를 바인딩하지 않는 함수 (arrow function)
   ES6 화살표 함수를 도입하며, 실행컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠지게 됨! => `상위 스코프의 this`를 그대로 활용가능!

   ```jsx
   var obj = {
     outer: function () {
       console.log(this); // (1) {outer:f}
       var innerFunc = () => {
         console.log(this); // (2) {outer:f}
       };
       innerFunc();
     },
   };
   obj.outer();
   ```

### 콜백함수 호출시 함수 내부에서의 this

제어권을 받은 함수에서 콜백 함수에 별도로 this가 될 대상을 지정한 경우에는 그 대상을 참조하게 된다

### 생성자 함수 내부에서의 this

생성자 함수 : 어떤 공통된 성질을 지니는 객체들을 생성하는데 사용하는 함수
`new` 명령어와 함께 함수를 호출하면 해당 함수가 생성자로서 동작하게 된다.
어떤 함수가 생성자 함수로서 호출된 경우 내부에서의 this는 곧 새로 만들 구체적인 `인스턴스 자신`이 된다

생성자 함수를 호출하면 우선 생성자의 prototype 프로퍼티를 참조하는 **proto**라는 프로퍼티가 있는 객체(인스턴스)를 만들고, 미리 준비된 공통 속성 및 개성을 해당 객체에 부여한다

### 명시적으로 this를 바인딩하는 방법

**1. call 메서드**
메서드의 호출 주체인 함수를 즉시 실행하도록 하는 명령
call 메서드의 첫 번째 인자를 this로 바인딩하고, 이후의 인자들을 호출할 함수의 매개변수로 사용한다
함수를 그냥 실행하면 this는 전역객체를 참조하지만, call 메서드를 이용하면 임의의 객체를 this로 지정할 수 있다

```jsx
var func = function (a, b, c) {
  console.log(this, a, b, c);
};

func(1, 2, 3); // Window{...} 1 2 3
func.call({ x: 1 }, 1, 2, 3); //{ x : 1 } 4 5 6
```

**2. apply 메서드**
call 메서드와 기능적으로 완전히 동일함.
call 메서드는 첫 번째 인자를 제외한 나머지 모든 인자들을 호출할 함수의 매개변수로 지정하는 반면, apply 메서드는 두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다는 점에서 차이가 있다

```jsx
var func = function (a, b, c) {
  console.log(this, a, b, c);
};
func.apply({ x: 1 }, [4, 5, 6]); // {x : 1} 4 5 6
```

**3. call / apply 메서드의 활용**

유사배열객체에 배열 메서드를 적용
객체에는 배열 메서드를 직접 적용할 수 없다.
그러나 키가 0 또는 양의 정수인 프로퍼티가 존재하고 length 프로퍼티의 값이 0 또는 양의 정수인 객체, 즉 배열의 구조와 유사한 객체의 경우 (유사배열객체) call 또는 apply 메서드를 이용해 배열 메서드를 차용할 수 있다

유사배열객체에는 call/apply 메서드를 이용해 모든 배열 메서드를 적용할 수 있다. 배열처럼 인덱스와 length 프로퍼티를 지니는 문자열에 대해서도 마찬가지다. 단, 문자열의 경우 length 프로퍼티가 `읽기 전용`이므로 원본 문자열에 변경을 가하는 메서드 (push, pop, shift, unshift, splice)는 에러를 던지며, concat 처럼 대상이 반드시 배열이어야하는 경우에는 에러는 나지 않지만 제대로 된 결과를 얻을 수 없음!

call/apply를 이용해 형변환하는 것은 this를 원하는 값으로 지정해서 호출한다라는 본래의 메서드 의도와는 다소 동떨어진 활용법임
-> ES6에서는 유사 배열객체 또는 순회 가능한 모든 종류의 데이터 타입을 배열로 전환하는 Array.from 메서드를 새로 도입함

```jsx
var obj = {
  0: "a",
  1: "b",
  2: "c",
  length: 3,
};
var arr = Array.from(obj);
console.log(arr); // [a, b, c]
```

생성자 내부에서 다른 생성자를 호출
생성자 내부에 다른 생성자와 공통된 내용이 있을 경우 call 또는 apply를 이용해 다른 생성자를 호출하면 간단하게 반복을 줄일 수 있음

여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 - apply 활용 or ES6 spread operator 활용

4. bind 메서드
   call 과 비슷하지만 즉시 호출하지는 않고 넘겨받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드
   -> bind 메서드는 함수에 this를 미리 적용하는 것과 부분 적용 함수를 구현하는 두 가지 목적을 모두 지닌다

- name 프로퍼티
  - bind 메서드를 적용하면, name 프로퍼티에 동사 bind의 수동태인 'bound'라는 접두어가 붙는다

```jsx
var func = function (a, b, c, d) {
  console.log(this, a, b, c, d);
};

var bindFunc = func.bind({ x: 1 }, 4, 5);
console.log(func.name); // func
console.log(bindFunc.name); // bound func
```

- 화살표 함수의 예외사항
  화살표 함수는 실행 컨텍스트 생성시 this를 바인딩하는 과정이 제외됨.
  즉, 이 함수 내부에는 this가 아예 없으며, 접근하고자 하면 스코프 체인상 가장 가까운 this에 접근하게 된다. => this를 우회하거나 apply/call/bind를 적용할 필요가 없음

  ```jsx
  var obj = {
    outer: function () {
      console.log(this); // {outer:f}
      var innerFunc = () => {
        console.log(this); // {outer:f}
      };
      innerFunc();
    },
  };
  obj.outer();
  ```

### 😤 오늘도 2depth 가보자구!

[`전역객체`](https://developer.mozilla.org/ko/docs/Glossary/Global_object)

- 전역범위에서 항상 존재하는 객체
- 웹 브라우저에서 스크립트가 전역변수를 생성할 때, 전역 객체의 멤버로서 생성됨
- 전역객체로써 Window를 가지는데, Node.js에서는 global로 호출되는 객체를 전역객체로 가진다
- window 객체는 브라우저에서 전역객체이므로, 어느 전역 객체나 함수는 window 객체의 프로퍼티로서 접근될 수 있다!
  ```jsx
  var foo = "foobar";
  foo === window.foo; // true
  ```

이 때, let이나 const 가 아닌 var로 선언한 전역 함수나 전역 변수는 전역 객체의 프로퍼티가 됨 -> 이게 let, const 를 써야하는 이유이기도 함!

```jsx
let foo = "foobar";
foo === window.foo; // false
```

**🤔만약 중요한 변수라서 전역객체로 등록하고 싶다면?**

=> 전역 객체에 `직접` 프로퍼티를 추가한다!

<img width="376" alt="스크린샷 2022-04-26 오후 1 49 54" src="https://user-images.githubusercontent.com/72402747/165223970-3c6c01b4-a5d1-45a7-9dd6-286eef5c34eb.png">

- `모듈`을 사용하면 전역변수가 아니라 [독자적인 모듈 스코프](https://ko.javascript.info/modules-intro)를 갖게 된다

참고 자료

- 전역객체 : https://ko.javascript.info/global-object
- 모듈 : https://ko.javascript.info/modules-intro

* 이번 스터디의 뿌듯한 점

벨로그 글을 참고하다가 오류를 발견하고 댓글을 남겨드렸다!
https://velog.io/@diveforme/%EC%A0%84%EC%97%AD%EA%B0%9D%EC%B2%B4

<img width="730" alt="스크린샷 2022-04-26 오후 2 01 47" src="https://user-images.githubusercontent.com/72402747/165225167-930a636b-9bce-4aaf-ba83-2de09f185535.png">
