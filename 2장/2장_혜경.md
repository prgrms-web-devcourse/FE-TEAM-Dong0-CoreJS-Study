- [실행 컨텍스트](#실행-컨텍스트)
  - [\* 스택과 [큐](https://github.com/Hyevvy/myDataStructure/blob/main/3.큐/큐%20Queue.md)](#-스택과-큐)
  - [실행컨텍스트는 콜 스택!](#실행컨텍스트는-콜-스택)
  - [실행 컨텍스트의 종류](#실행-컨텍스트의-종류)
  - [environmentRecord와 호이스팅](#environmentrecord와-호이스팅)
    - [호이스팅 뿌셔버리기](#호이스팅-뿌셔버리기)
    - [함수 선언문과 함수 표현식](#함수-선언문과-함수-표현식)
  - [원활한 협업을 위해](#원활한-협업을-위해)
  - [스코프, 스코프 체인](#스코프-스코프-체인)
  - [😤1.5 depth까지 가보자구 !](#15-depth까지-가보자구-)
    - [👊 eval() 이 뭘까?](#-eval-이-뭘까)

## 실행 컨텍스트

- 실행할 코드에 제공할 환경 정보들을 모아놓은 객체 **(코드의 실행 환경)**

### \* [스택](https://github.com/Hyevvy/myDataStructure/blob/main/2.스택/스택%20stack.md)과 [큐](https://github.com/Hyevvy/myDataStructure/blob/main/3.큐/큐%20Queue.md)

스택은 후입선출! (먼저 들어온 것이 나중에 나감!)
![IMG_0026](https://user-images.githubusercontent.com/72402747/104802310-074cdc80-5814-11eb-9194-be2bf6092255.jpg)

</br>

큐는 선입선출! (먼저 들어온 것이 먼저 나가!)
![큐](https://user-images.githubusercontent.com/72402747/105804015-1127ca00-5fe2-11eb-8e05-74b51f91f7da.jpg)

</br>

### 실행컨텍스트는 콜 스택!

실행컨텍스트는 **실행할 코드에 제공할 환경 정보들을 모아놓은 객체**로, 콜 스택에 쌓아 올려서 `가장 위`에 쌓여있는 컨텍스트와 관련있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장한다!

=> 아니 그러면 그냥 같은 실행 컨텍스트를 구성하면 되는거아냐? 🤔

전역공간(자동으로 생성됨), eval() (얘는 악마), 함수 , {}
---> 즉.. 우리가 실행 컨텍스트를 구성하는 방법은 **함수, {}** 를 실행하는 것 뿐...!

=> 😮 그럼 console에다가 실행 컨텍스트 찍어보고 코드짜면 더 편하지 않을까?
NOPE!! 실행 컨텍스트는 `JS 엔진이 활용`할 목적으로 생성할 뿐 개발자가 코드를 통해 확인할 수는 없음!

</br>

### 실행 컨텍스트의 종류

- `VariableEnvironment` : 현재 컨텍스트 내 식별자들에 대한 정보 + 외부 환경 정보, 선언 시점의 스냅샷! (변경사항 반영 X)
- `LexicalEnvironment` : 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨

- `ThisBinding` : this 식별자가 바라봐야 할 대상 객체

1. `VariableEnvironment`

   - 실행 컨텍스트를 생성할 때 `VariableEnvironment` 에 정보를 먼저 담은 다음, 이를 복사해서 `LexicalEnvironment`를 만든다.
   - 초기화 과정중에는 사실상 완전히 동일하고 이후 코드 진행에 따라 달라짐

2. `LexicalEnvironment`

   - lexical 은 '어휘적', '정적'이라는 의미인데 여기서는 '사전적'이라는 의미가 좀 더 어울림
   - 즉, 컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아놓은 것!

### environmentRecord와 호이스팅

- environmentRecord 에 현재 컨텍스트와 관련된 코드의 식별자 정보들(매개변수의 이름, 함수 선언, 변수명)이 저장됨.
- 컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며 `순서대로` 수집한다.
- 코드가 실행되기 전임에도 자바스크립트 엔진은 이미 해당 환경에 속한 코드의 변수명을 알고 있음
  => **✨호이스팅!**
  '자바스크립트 엔진은 식별자들을 최상단으로 끌어올려놓은 다음 실제 코드를 실행한다'

#### 호이스팅 뿌셔버리기

```jsx
function f(x) {
  console.log(x);
  var x;
  console.log(x);
  var x = 2;
  console.log(x);
}
f(1);
```

=> 어떤 결과가 나올까?

```jsx
function f(x) {
  var x;
  var x;
  var x;
  x = 1;
  console.log(x); // 1
  console.log(x); // 1
  x = 2;
  console.log(x); // 2
}
f(1);
```

environmentRecord는 현재 실행될 컨텍스트 대상 코드내에 `어떤 식별자들이 있는지`에만 관심있음! 각 시별자에 어떤 값이 할당될 것인지는 관심 NOPE!

```jsx
  function x(){
    console.log(b);
    var b = 'bbb';
    console.log(b);

    function b({});
    console.log(b);
  }
  x();
```

=> 호이스팅!

```jsx
  function x(){
    var b;
    function b({});

    console.log(b); // b()
    b = 'bbb';
    console.log(b); // bbb
    console.log(b); // bbb
  }
  x();
```

#### 함수 선언문과 함수 표현식

`함수 선언문` : function 정의부만 존재하고 별도의 할당 명령없음
`함수표현식` : 정의한 function을 별도의 변수에 할당하는 것 (함수를 다른 변수에 값으로써 `할당`함)

```jsx
function a() {} //함수 선언문

//함수 표현식
var b = function () {}; // 익명함수 표현식 , b가 함수명이 됨

var c = function d() {}; // 기명함수 표현식, c는 변수명, 함수명은 d

c(); // ok
d(); //error, 기명함수 표현식은 외부에서 함수명으로 접근 불가, c 함수 내부에서만 가능
```

🤔 요즘은 대부분 익명함수 표현식을 쓰는데 왜 기명함수 표현식이 생겨났을까?
=>
이전에는 기명 함수 표현식은 함수명이 잘 출력되고, 익명함수 표현식은 undefined, unnamed라는 값이 나왔음! 그래서 디버깅을 위해 기명 함수 표현식을 썼음
그러나 이제는 모든 브라우저들이 익명 함수 표현식의 변수명을 함수의 name 프로퍼티에 할당하고 있음

함수 선언문은 전체를 호이스팅하고,
함수 표현식의 변수는 선언부만 끌어올린다.
변수 할당부는 원래 자리에 남겨 둔다

함수 선언문은 선언하기 전에 함수를 호출해도 잘 동작한다.
=> 동일한 변수명에 서로 다른 값을 할당할 경우 `나중`에 할당한 값이 먼저 할당한 값을 덮어씌운다
=> 즉, 맨 마지막에 선언된 함수가 실제 호출됨!
=> 오류찾기가 어려움!

### 원활한 협업을 위해

- 전역공간에 함수를 선언하거나 동명의 함수를 중복 선언하는 경우는 없애자!
- 함수 선언식보다는 함수 표현식을 쓰자!

### 스코프, 스코프 체인

`스코프` : 식별자에 대한 유효범위
`스코프체인` : 식별자의 유효범위를 안에서 바깥으로 차례로 검색해나가는 것

여러 스코프에서 동일한 식별자를 선언한 경우 무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능하다

### 😤1.5 depth까지 가보자구 !

---

#### 👊 [eval()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/eval) 이 뭘까?

eval(string)

- 문자로 표현된 JavaScript 코드를 실행하는 함수
- 인자로 `string`을 받고, 인자가 표현식을 나타낸다면 eval()은 표현식을 평가함. 만약, 인자가 문자열이 아니면 인자를 그대로 반환함

  - 연산식을 계산하기 위해 eval()을 호출하지말 것!
  - js는 알아서 연산식을 계산해주니까!

    ```jsx
    eval(new String("2 + 2")); // "2 + 2"를 포함한 String 객체를 반환
    eval("2 + 2"); // 4를 반환
    ```

- 주어진 코드를 평가하여 얻은 값을 리턴하고, 값이 없다면 `undefined`를 반환함
- `전역 객체`의 함수 속성
- eval을 직접 호출하지 않고 참조를 통해 간접적으로 사용하면 `전역범위`에서 동작함
  - eval로 함수를 선언하면 전역함수가 되고, 실행되는 코드는 실행되는 위치의 지역 범위에 접근할 수 없음
    ```jsx
    function test() {
      var x = 2,
        y = 4;
      console.log(eval("x + y")); // 직접 호출, 지역 범위 사용, 결과값은 6
      var geval = eval; // eval을 전역 범위로 호출하는 것과 같음
      console.log(geval("x + y")); // 간접 호출, 전역 범위 사용, `x`가 정의되지 않았으므로 ReferenceError 발생
      (0, eval)("x + y"); // 다른 방식으로 간접 호출
    }
    ```
- ❗️eval을 절대 사용하지말 것
  1. 제 3자가 eval()이 호출된 위치의 스코프를 볼 수 있음
  2. 악의적인 영향을 받았을 수 있는 문자열을 eval()로 실행한다면, 악의적인 코드를 수행하는 결과를 초래함
  3. 최신 js엔진에서 최적화해주지 않고, eval()은 js 인터프리터를 사용해야하므로 다른 대안들보다 `느림`
  4. eval()을 통해 자료형 변경등 `변수에 변화`가 일어날 수 있음
     => eval() 대신 function()을 사용할 것
