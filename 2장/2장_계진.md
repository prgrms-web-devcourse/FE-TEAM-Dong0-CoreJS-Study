# 2. 실행 컨텍스트(Execution Context)

## 1. 실행 컨텍스트란?

- 콜 스택((call stack)) : 프로그램의 함수 실행을 기록하는 자료구조
- 실행 컨텍스트 : 실행할 코드에 제공할 환경 정보들을 모아놓은 객체
  - 전역과 eval()을 제외하면 **함수 실행** 으로 실행 컨텍스트를 구성하고, 이 컨텍스트들은 콜 스택을 통해 실행된다.
  - 컨텍스트의 정보에는 VariableEnvironment, LexicalEnvironment, ThisBinding 컴포넌트가 있다.

```javascript
// 순서 예시
function foo() {
  throw new Error("앗");
}

function bar() {
  foo();
}

function baz() {
  bar();
}

baz();
// Uncaught Error: 앗
//     at foo (<anonymous>:2:9)
//     at bar (<anonymous>:6:3)
//     at baz (<anonymous>:10:3)
//     at <anonymous>:13:1
```

## 2. VariableEnvironment

- 실행 컨텍스트 생성 시 environmentRecord, outerEnvironmentReference의 스냅샷(초기 상태)을 유지

## 3. LexicalEnvironment

- VariableEnvironment의 environmentRecord, outerEnvironmentReference를 복사한 객체로 구성, 변경 사항 즉시 반영

```javascript
// VariableEnvironment 사용, LexicalEnvironment 변화
function change() {
  console.log(a); // undefined
  var a = 1;
  console.log(typeof e); // undefined
  try {
    // try-catch로 새 LexicalEnvironment 생성
    // change 함수의 실행 컨텍스트 생성 시 e가 수집되지 않음
    console.log(e); // ReferenceError: e is not defined,
  } catch (e) {
    console.log(a); // 1,  undefined이 아닌 change 함수의 VariableEnvironment를 참조
    console.log(e); // It works here!!!
    console.log(typeof e); // object
    var a = 3;
  }
}
change();
```

참조 : [VariableEnvironment는 왜 필요할까?](https://sambalim.tistory.com/155)

### environmentRecord

- 현재 컨텍스트와 관련된 코드의 식별자 정보(매개변수 이름, 함수 선언, 변수명 등) 순서대로 저장, 해당 환경의 변수명들을 모두 알고 있음
- 호이스팅(Hoisting) : JS 엔진은 식별자들을 최상단으로 올리고(수집) 실제 코드를 실행한다는 가상의 개념
  - 선언과 할당이 동시에 이루어졌다면, 선언만 최상단으로 끌어올린다고 생각하자

```javascript
// 호이스팅이 없었을 때 예상
function a() {
  console.log(b); // undefined
  var b = "bbb";
  console.log(b); // "bbb"
  function b() {}
  console.log(b); // function b
}

a();

// 호이스팅이 있고, 해석하기 쉽게 변형한 올바른 결과
function a() {
  var b;
  var b = function b() {}; // 함수 선언문은 전체를 수집, 함수명으로 선언한 변수에 함수를 할당한 것으로 여김

  console.log(b); // function b
  b = "bbb"; // 변수 b에 함수를 가리키는 주솟값 대신 "bbb"의 주솟값으로 덮어씀
  console.log(b); // "bbb"
  console.log(b); // "bbb"
}

a();
```

### 함수 선언문과 함수 표현식

- 함수 선언문(function declaration) : 전체가 호이스팅 됨.
  - `function a() {}`
  - 프로그램의 흐름상 이해하기 어려운 부분이 생길 수 있음.
- 함수 표현식(function expression) : 함수를 다른 변수에 할당, 변수 선언부`var 변수명;`만 호이스팅 됨.
  - `var b = function() {}`(익명), `var c = function d() {}`(기명)
  - 변수의 할당부 이후에야 호출이 가능하기 때문에 상대적으로 디버깅이 쉬워진다.

### outerEnvironmentReference, 스코프, 스코프 체인,

- outerEnvironmentReference : 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조
- 스코프 : 식별자에 대한 유효 범위
- 스코프 체인 : outerEnvironmentReference를 통해 스코프를 안에서 밖으로 차례대로 검색, 없으면 Reference Error
  - 스코프 체인 상에서 먼저 발견된 식별자에만 접근 가능
  - 변수 은닉화(variable shadowing) : 함수 내부와 외부에 동일한 이름의 변수가 있다면 외부 변수에는 접근할 수 없음

```javascript
// scope chain
var a = 1;
var outer = function () {
  var inner = function () {
    console.log(a); // undefined
    var a = 3;
  };
  inner();
  console.log(a); // outer의 environmentRecord에 a가 없으므로, outerEnvironmentReference인 전역 LexicalEnvironment의 a 값, 1
};
outer();
console.log(a); //
```

### 전역 변수와 지역 변수

- 전역 컨텍스트의 LexicalEnvironment에 담긴 변수는 전역 변수, 그 외는 모두 지역 변수
- 스코프를 고려하여 코드의 안전성을 높이려면 전역 변수 지양

## 4. this

- 실행 컨텍스트의 thisBinding에는 this에 들어갈 객체 지정
  - 활성화 될 때 this가 지정되어 있지 않다면 전역 객체로 지정
