# 데이터 타입

데이터 타입은 크게 기본형 참조형으로 나뉜다.

## 데이터 타입의 종류

> 기본형 : `Number`, `String`,`Boolean`,`null`,`undefined` + `Symbol`(ES6)
> 참조형 : `Object`,`Array`,`function`,`Date`,`RegExp`

두가지 타입을 구분하는 기준 : 할당이나 연산시에 복제되는 대상

- 기본형 : 값이 담긴 주솟값을 복제
- 참조형 : 주솟값을 가리키는 주솟값을 복제

:thinking: 개인적으로 참조형은 C++ 포인터를 복제한다고 이해했습니다

## 데이터 타입에 관한 배경지식

### 메모리와 데이터

각 1bit는 고유한 식별자를 가지고 있음
8bit = 1byte로 묶어 시작 bit를 식별자로 사용함 (메모리 주솟값)

:thinking: 기본적으로 8byte를 Number에 할당한다고 했는데, 그보다 더 큰 경우(절대 발생할리는 없겠지만)는 error가 발생하는지 궁금해졌다. 하지만 정상적으로 연산은 실행되는걸 보니 Number도 지정된 길이를 넘어가는 데이터가 발생하면 데이터 영역에서 동적으로 길이를 설정하는것 같다.

## 변수 선언과 데이터 할당

`var a = 'abc';`이라고 선언하면 발생하는 일.

1.  x(임의의 메모리 주소)에 식별자 a인 공간이 생긴다
2.  해당 공간에 직접 'abc'값을 할당하지 않고 새로운 y(데이터 영역)에 값을 저장한다. x의 값 부분에 y주소를 저장한다

> 미리 지정된 공간에 값을 할당하면 데이터 길이가 가변적인 상황에서는 배열의 중간 단계 삽입과 같은 현상이 발생하기 때문에 비효율적이다.

`var a = 'abcdef';`로 재할당하면.

1. 기존 y주소의 값에 변경이 일어나지 않고, 새로운 z 주소에 'abcdef'를 저장
2. 변경된 z주소를 x의 값 부분에 할당

`var b = 'abcdef';`인 경우에 이미 데이터 영역 z주소에 'abcdef'값이 존재하기 때문에 새로운 변수인 b도 값 부분에서는 동일한 z주소를 가리키게 됨

## 기본형 데이터와 참조형 데이터

### 불변값

1. 변수(variable) vs 상수(constant)
   변수 영역 메모리에서의 비교! 변수에 저장된 값(데이터 영역의 주소)의 변경 가능성
2. 불변성
   데이터 영역의 메모리가 기준

> :bulb: JS의 원시타입은 전부 불변값이다. 한번 데이터 영역에 할당된 값은 가비지 콜렉터에 의해 수거되기 전까지 영원히 변하지 않는다!

### 가변값

참조형 데이터는 전부 가변값? => 대체로 그렇다 (불변값으로 활용하는 방안도 있다)

#### 참조형 데이터의 할당

```javascript
var obj1 = {
  a: 1,
  b: 'bbb',
};
```

1. 주소 x에 식별자 obj1 공간 할당
2. 데이터 영역에 y1주소에 공간 할당, 주소 x의 값에 y1 할당
3. y1 주소의 값에는 z1~?(객체의 변수 영역의 주솟값)을 할당
4. z1에는 식별자a 값 y2, z2에는 식별자b 값 y3을 할당
5. y2,y3영역에는 각각 1, 'bbb'가 저장

`obj1.a = 2`로 객체 내부의 프로퍼티 값을 바꾸면, 객체는 기존에 가리키고 있던 값인 y1을 그대로 가리키면서 기존 a 가 가리키는 값이 y2에서 새로운 2의 주소y4로 바뀌게 됩니다.
:thinking: 이후에 중첩객체는 그림 없이 글로 설명하기에는 동일한 말이 반복될거 같습니다. 결국 참조형 데이터의 핵심은 **참조형 데이터 내부의 프로퍼티 데이터 그룹의 변수 영역이 별도로 생긴다**입니다. 하지만 데이터 영역은 공유하는 점을 이해하면 참조형 데이터의 선언 및 할당을 이해할 수 있습니다!

### 변수 복사 비교

```javascript
var a = 10;
var b = a;

var obj1 = { c: 10, d: 'ddd' };
var obj2 = obj1;

b = 15;
obj2.c = 20;
```

이때, 처음 복사가된 b 변수는 a와 같은 주솟값을 할당 받았다가 값이 변경되는 순간 새로운 15를 할당한 주솟값을 갖게된다. 결과적으로 a,b둘다 다른 주솟값을 할당받은 상태가 된다. obj1, obj2는 obj2가 프로퍼티 c의 값을 변경해도 별도의 객체 변수 영역에서의 c 프로퍼티의 할당된 값이 변하기 때문에 obj1의 proprety c도 값이 변하게 된다.

`obj2 = {c:10, d:'ddd'}` 이 복사에 대해서는 새로운 객체를 생성해 obj2의 값(주솟값) 자체를 바꾸는 할당이기 때문에 당연히 `obj1 !== obj2`가 된다.

## 불변객체

위의 예시에서 obj1을 obj2에 그대로 할당하고 obj2의 내부 프로퍼티를 변경하면 obj1의 프로퍼티도 똑같이 변경되는 이슈가 있었다. 결국 obj1의 프로퍼티들은 그대로 유지되어야 하는 필요성이 있음에도 불변성을 유지할 수 없다.

> 결국 기존 객체를 그대로 유지하려면 기존 객체의 프로퍼티를 동일하게 가진 객체를 **새로 생성해서 할당**해야한다.

## 얕은 복사 vs 깊은 복사

> - 얕은복사 (shallow copy): 바로 아래 단계의 값만 복사
> - 깊은 복사 (deep copy): 내부의 모든 깊이까지 전부 복사

결국 참조형 데이터들은 값을 2번씩 참조해야 하기 때문에 (변수영역의 값 => 데이터 영역의 값 => 객체 변수의 값 => 실제 데이터) 내부의 프로퍼티중에 중첩된 참조값이 존재한다면 해당 프로퍼티는 복사 되었을 때 동일한 객체 주소값을 참조하게 된다.

### 해결 방법

1. 재귀적으로 모든 하위 객체들을 새롭게 생성해 할당하기
2. JSON 형식으로 변경했다가 다시 parsing후 return하기
3. 라이브러리의 힘을 빌리기 (ex. [lodash](https://velog.io/@recordboy/JavaScript-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%ACShallow-Copy%EC%99%80-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%ACDeep-Copy#lodash-%EB%AA%A8%EB%93%88%EC%9D%98-clonedeep))

:thinking: 사실 깊은복사에 대해서 전혀 생각해본적이 없습니다. 코딩을 하면서 경험적으로 참조 타입들을 직접 `=` 연산자로 복사하게 되면 동일한 주솟값을 가리킨다는건 알고 있었지만 주로 사용하는 Spread (`...`)연산자를 사용하면 알아서 Deep copy로 중첩 객체들도 별도 복사가 될줄 알았는데.. 위에서 참조 변수의 선언 할당을 실제 동작으로 한 단계씩 이해하면서 내려오니 Deep Copy는 별도의 처리가 없는 이상 절대 불가능 하다는 사실을 깨닫게 됐습니다!!

## undefined & null

### undefined가 반환되는 경우

1. 값을 대입하지 않은 변수에 접근할 때
2. 객체 내부의 존재하지 않는 프로퍼티에 접근할 때
3. return문이 없거나 호출되지 않는 함수의 실행 결과

> 해당 파트에서 가장 집중해야 하는 부분은 **undefined는 자바스크립트 엔진이 반환 가능한 값**으로만 사용해서 혼동을 피해야 한다는 점

### typeof null === object?

자바스크립트 자체 버그로 null checking에서 typeof를 쓰는것은 지양해야 한다. 또한 `undefined == null` 동등 연산자로 비교했을 때 `true`를 반환하기 때문에 `===` 일치 연산자로 두 값을 비교해야 한다.
