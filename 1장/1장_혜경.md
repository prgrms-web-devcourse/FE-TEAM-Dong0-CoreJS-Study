- [데이터 타입의 종류](#데이터-타입의-종류)
- [데이터 타입에 관한 배경지식](#데이터-타입에-관한-배경지식)
- [기본형 데이터와 참조형 데이터](#기본형-데이터와-참조형-데이터)
- [변수 복사 비교](#변수-복사-비교)
- [불변객체](#불변객체)
- [얕은 복사와 깊은 복사](#얕은-복사와-깊은-복사)
- [undefined와 null](#undefined와-null)

### 데이터 타입의 종류

크게 기본형과 참조형으로 나뉜다.

- 기본형 : number, string, boolean, null, undefined, symbol

  - 할당이나 연산시 복제되고 참조형은 참조된다
  - 값이 담긴 주솟값을 바로 복제한다.
  - 불변성을 띈다.

- 참조형 : object, array, function, date, map, set
  - 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제한다

### 데이터 타입에 관한 배경지식

1. 메모리와 데이터

   - 메모리 : 매우 많은 비트(0 또는 1만 표현할 수 있는 하나의 메모리 조각)들로 구성됨
     => 비트들은 고유한 식별자를 통해 위치를 확인할 수 있음
     => 1바이트(8비트)
     => 자바스크립트는 메모리 용량이 커진 상태에서 등장해서 메모리 공간을 넉넉하게 할당했음!
     => 개발자들이 형변환을 걱정할 필요 ❌
     => 모든 데이터는 **바이트 단위의 식별자 (메모리 주솟값)**을 통해 서로 구분하고 연결할 수 있다

2. 식별자와 변수

   - 변수 : 변할 수 있는 무언가(데이터)
   - 식별자 : 데이터를 식별하는 데 사용하는 이름, 즉 **변수명**

3. 변수 선언과 데이터 할당

   다음과 같이 변수를 선언한다고 생각해보자!
   ![IMG_0199](https://user-images.githubusercontent.com/72402747/160892265-68f37c1b-fbb4-48d0-9e80-8d35f3b453d4.jpg)

   우선 주소는 **변수 영역과 데이터 영역**으로 나뉜다. 값을 대입할 때 바로 대입하는 것이 아닌 데이터 영역에 값을 저장하고 그 주소를 대입한다.

   <br/>

   😮왜 변수 영역에 직접 값을 대입하지 않고 굳이 한 단계 더 거치는 것일까?

   - 숫자형 데이터는 64비트 공간 확보, 문자열은 정해진 규격 X
   - 만약 미리 확보한 공간 내에서만 데이터 변환을 할 수 있다면 변환한 데이터를 다시 저장하기 위해 **확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업**이 선행되어야함
   - 해당 공간이 메모리 상의 중간에 있었다면 다 전부 뒤로 옮기고,, 이동시킨 주소를 각 식별자에 연결하고,, 벌써 머리 아픔... ㄷ ㄷ

   => `효율적으로 문자열 데이터의 변환을 처리` 하기 위해 변수와 데이터를 별도의 공간에 나누어 저장한다!

   <br/>

   a 에 "abcde"를 넣는다면 "abcde" 문자열을 새로 만들어 별도의 공간에 저장하고, 그 주소를 변수 공간에 연결한다.

   ![IMG_0200](https://user-images.githubusercontent.com/72402747/160892270-7fbcae45-d23b-4b9b-918e-9ca0ce264ebe.jpg)

   - 기존 @5003의 데이터는 자신의 주소를 저장하는 변수가 하나도 없게 되면 가비지 컬렉터의 수거 대상이 된다!

### 기본형 데이터와 참조형 데이터

- #### 불변값

  - 변수와 상수 구분 기준 : **변경 가능성**
  - 불변값 != 상수
  - 변수와 상수를 구분 짓는 변경 가능성의 대상은 **변수 영역 메모리**이다
    - 한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 중요
  - 불변성 여부를 구분할 때 변경가능성의 대상은 **데이터 영역 메모리**이다

  - 기본형 데이터인 숫자, 문자열, boolean, null, undefined, Symbol은 모두 불변값이다. 기존에 있던 값을 바꾸는 것이 아니라 새로 만든다.

    - 변경은 새로 만드는 동작을 통해서만 이루어짐
    - 한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않음

  - #### 가변값

    ![IMG_0201](https://user-images.githubusercontent.com/72402747/160897418-859fce96-55d4-4b5d-bb79-acfaae3c1f77.jpg)

    객체의 변수 영역

    - 객체가 별도로 할애한 영역은 변수 영역일 뿐 데이터 영역은 기존의 메모리 공간을 그대로 활ㅇ용하고 있음
    - 데이터 영역에 저장된 값은 모두 불변! 그러나 변수에는 다른 값을 얼마든지 대입가능

* 정말 중요

  - obj1가 @5001 을 값으로 가지고 있음
  - @5001은 객체의 변수영역으로 주소들을 가지고 있음 (만약 obj1의 요소가 바뀐다면 주소들이 바뀜!)

  ```
    주소 | 5001
    데이터 | @7103 ~ ?
  ```

  - @5001이 가지고 있는 주소들에 가보면 `식별자(변수명)`와 `값(주소)`를 가지고 있음

    ```
        7103
        이름 | a
        값 | @5005
    ```

  - @5005에 가면 데이터가 있음
    ```
        2
    ```

### 변수 복사 비교

```
let a = 3;
let b = a;
```

a 와 b는 모두 같은 데이터 영역의 주소를 바라본다.

```
  let obj1 = { c : 10 , d : 'hi'}
  let obj2 = obj1
```

obj1과 obj2는 모두 같은 주소를 바라본다

변수를 복사하면 기본형 데이터와 참조현 데이터 모두 같은 주소를 바라본다

😮 값을 수정하면 어떻게 될까?

```
  b = 15;
```

b의 값인 15가 데이터 영역에 없으므로 새로운 공간에 저장하고 그 공간을 b가 바라보게 되므로, a와 b는 이제 각기 다른 주소를 바라본다

```
  obj2.c = 33
```

obj2의 c의 값을 바꾸어도 내부 프로퍼티를 바꾼 것이므로 obj1과 obj2는 같은 주소를 바라본다

=> 기본형은 주솟값을 복사하는 과정이 한 번만 이루어지고, 참조형은 한 단계 더 거친다!

🤔객체 자체를 바꿔버리면 어떻게 될까?

```
  obj2 = {
    c: 8,
    d: "bye"
  }
```

객체가 바뀐 것이므로 아예 새로운 공간을 할당하고 이 주소를 바라보므로 객체 자체를 변경하면 주소가 달라진다.

즉, 참조형 데이터가 `가변값`이라고 설명할 때의 `가변`은 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티(obj2.c)를 변경할 때만 성립한다

### 불변객체

값으로 전달받은 객체의 프로퍼티에 변경을 가해도 원본 객체가 변하지 않아야하는 경우가 있다

obj1의 프로퍼티가 하나 바뀐다고 obj2의 프로퍼티도 바뀌는 것을 막아야하는 경우가 있다는 의미!

🤔 어떻게 불변객체를 만드는데?
직접 개발자가 정의해도 되지만, 그 정의한 함수를 통해서만 객체를 만든다는 보장이 없으니 `시스템적으로 제약` 이 필요하다!

=> immutable.js, baobab.js

### 얕은 복사와 깊은 복사

얕은 복사는 바로 아래 단계의 값만 복사하는 방법!
참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사함

🙄 문제점

- 사본을 바꾸면 원본도 바뀌고,
  원본을 바꾸면 사본도 바뀐다

=> `불변객체`로 만들면 해결!

**객체의 프로퍼티 중 그 값이 기본형 데이터이면 그대로 복사해도 되지만, 참조형 데이터는 다시 그 내부의 프로퍼티들을 복사해야함!**

🙄 매번 깊은 복사하는거 너무 귀찮아!
=> 객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾸면 깊은 복사가 됨
(메서드나 숨겨진 프로퍼티인 \_*proto*나 getter/setter등 JSON 으로 변경할 수 없는 프로퍼티들은 무시함, 순수한 정보를 다룰때만 활용하기 좋음!)

```
  function(target){
    return JSON.parese(JSON.stringify(target))
  }
```

### undefined와 null

✨undefined

- 값을 대입하지 않은 변수, 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
- 객체 내부의 존재하지 않는 프로퍼티에 접근할 때
- return문이 없거나 호출되지 않는 함수의 실행결과
- 사용자가 임의로 undefined로 지정하는 경우

사용자가 직접 정의한 undefined : 값으로써 어딘가에 할당된 실존하는 데이터

자바스크립트 엔진이 반환해주는 undefined : 문자 그대로 값이 없음

=> 헷갈리므로 사용자가 직접 undefined를 설정하지않는게 좋음

😮아니 그럼 비어있는 값은 어떻게 표현해여..?
`null`...
단, typeof null은 object임.. ㄷ ㄷ
실제로 null인지 undefined인지는 `일치 연산자(===)`를 써야만 판별가능
