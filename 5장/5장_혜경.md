## 클로저

### 클로저의 의미 및 원리 이해
클로저란 ? 
```
    함수와 그 함수가 선언될 당시의 Lexical environment의 상호관계에 따른 현상
    => 어떤 함수에서 선언한 변수를 참조하는 내부 함수에서만 발생하는 현상
```

```jsx
    var outer = function(){
        var a = 1;
        var inner = function(){
            console.log(++a);
        }
        inner();
    }

    outer(); // 2
```
위의 경우는 outer함수의 실행 컨텍스트가 종료되면 LexicalEnvironment에 저장된 식별자들(a, inner)에 대한 참조를 지운다 -> 가비지 컬렉터의 수집대상이 됨

```jsx
    var outer = function(){
        var a = 1;
        var inner = function(){
            return ++a;
        }
        return inner();
    }

    var outer2 = outer();
    console.log(outer2) // 2
    console.log(outer2) // 2
```
-> outer함수의 실행 컨텍스트가 종료된 시점에는 a 변수를 참조하는 대상이 없어짐
-> a, inner변수의 값들은 가비지 컬렉터에 의해 소멸됨

```jsx
    var outer = function(){
        var a = 1;
        var inner = function(){
            return ++a;
        }
        return inner;
    }

    var outer2 = outer();
    console.log(outer2()) // 2
    console.log(outer2()) // 3
```

inner함수 실행 결과가 아닌 inner함수 자체를 반환함 -> 가비지컬렉터가 수집하지 않음!


**가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함시키지 않음**

3번째 예제의 a는 가비지컬렉터의 수거 대상에 포함 X

=> 클로저란 어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상

-> 외부로 전달이 단순히 return만을 의미하는 것은 아니다

=> 지역변수를 참조하는 내부함수를 외부에 전달하면 클로저! 
ex) setInterval, setTimeout, addEventlistener... 등등


### 클로저와 메모리 관리

클로저는 GC 수거대상이 아님 -> 그렇다면 메모리 소모가 큰가 ? 
=> NO!!

=> 클로저는 어떤 필요에 의해 의도적으로 함수의 지역변수를 메모리를 소모하도록 함으로써 발생함!
=> 필요성이 사라진 시점에 메모리를 소모하지 않도록 하면 됨! 
=> 어떻게 ? `참조 카운트를 0`으로 만든다! 즉, 참조형이 아닌 `기본형 데이터(null, undefined)` 할당!

예시

**1. 함수 참조를 끊어버리기**
   
```jsx
     var outer = function(){
        var a = 1;
        var inner = function(){
            return ++a;
        }
        return inner;
    }

    var outer2 = outer();
    outer2 = null;
```

**2. setInterval에 의한 클로저 메모리 해제**
   ```jsx
    (function(){
        var a = 0;
        var intervalId = null;
        var inner = function(){
            if(++a > 10){
                clearInterval(intervalId);
                inner = null;
            }
            console.log(a)
        }
        intervalId = setInterval(inner, 1000)
    })();
   ```

   <img width="291" alt="스크린샷 2022-05-10 오전 12 11 31" src="https://user-images.githubusercontent.com/72402747/167440627-cbb9f04c-d1b6-467a-8022-9489d2676ef1.png">

    3. eventListener에 의한 클로저의 메모리 해제
   ```jsx
    (function(){
        var count = 0;
        var button = document.createElement("button");
        button.innerText = 'click';

        var clickHandler = function(){
            console.log(++count, 'times clicked');
            if(count>=10){
                button.removeEventListener('click', clickHandler);
                clickHandler = null // clickHandler 식별자 함수 참조를 끊음
            }
        }

        button.addEventListener('click', clickHandler)
        document.body.appendChild(button)
    })()
   ```