# 클로저

## 의미

MDN문서: 클로저는 함수와 그 함수가 선언될 당시의 lexical environment의 상호관계에 따른 현상

```
var outer= function (){
    var a=1;
    var inner=function(){
        console.log(++a);
    };
    inner();
};
outer();
```

outer에서 a선언, inner함수에서 a를 증가하고 출력, inner는 a를 선언 하지 않았으니 상위 컨텍스트인 outer의 LexicalEnvironment 가서 a를 찾음. outer의 실행 컨텍스트가 종료되면 LexicalEnvironment에 저장된 식별자들에 대한 참조를 지움 => GC가 가져감\

inner 함수의 실행 시점에는 outer 함수는 이미 실행이 종료되어 있는데 어떻게 outer의 LexicalEnvironment에 접근할까?  
=> 가비지 콜렉터의 동작방식. => 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함x

클로저란 어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 **외부로 전달**할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수a가 사라지지 않는 현상.

### 외부로 전달하는 방법

1. setInterval/setTimeout
2. eventListener

## 클로저와 메모리 관리

### 메모리 누수?

개발자가 의도적으로 참조 카운트를 0이 되지 않게 설계한 경우 누수라고 보기는 어렵다. => 메모리 소모

최근 JS 엔진에서는 의도치 않은 누수가 발생하지 않거나 거의 발견 x.=> 의도대로 설계한 메모리 소모를 파악해서 적용하면 됨

클로저는 어떤 필요에 의해 의도적으로 함수의 지역변수를 메모리를 소모하도록 함으로써 발생하므로, 더 이상 필요성이 사라진 시점에 참조 카운트를 0을 만들어 GC가 수거하도록 하면 된다.
=> 식별자에 참조형이 아닌 기본형 데이터(null이나 undefined)를 할당하면 됨.

### 클로저의 메모리 관리

1. return 에 의한 클로저의 메모리 해제
2. setInterval 에 의한 클로저의 메모리 해제
3. eventListener 에 의한 클로저의 메모리 해제

## 클로저 활용 사례

### 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때

1. 콜백함수를 내부함수로 선언해서 외부 변수를 직접 참조
2. bind 메서드로 값을 직접 넘겨 클로저 발생 없이 사용(제약사항 발생)
3. 콜백 함수를 고차함수로 바꿔서 클로저를 적극적으로 사용

클로저로 만들 수 있지만 외부로 분리하는 것이 더 나을 수도 있을까? => bind를 사용해서 꺼낼 수도 있다. => 이벤트 객체가 인자로 넘어오는 순서가 바뀌는 점 및 함수 내부에서의 this가 달라짐. => 고차함수를 활용

각각의 방법의 장단점을 파악하여 상황에 따라 사용하는 것이 좋다.

### 접근 권한 제어 (정보 은닉)

> 정보은닉: 어떤 모듈의 내부 로직에 대해 외부로의 노출을 최소화해서 모듈간의 결합도를 낮추고, 유연성을 높이고자 하는 현대 프로그래밍 언어의 중요한 개념

자바스크립트는 기본적으로 변수 자체에 접근권한(public, private, protected)을 직접 부여할 수 없다. => 클로저를 사용하여 public과 private을 구분할 수 있다.

외부 스코프에서 함수 내부의 변수들 중 선택적으로 일부의 변수에 대한 접근 권한을 부여할 수 있다. => return을 통해서

외부에서는 외부 공간에 노출되어 있는 변수를 통해 외부함수를 실행할 수 있지만 함수 내부에는 어떠한 개입도 할 수 없다. 외부에서는 함수가 return한 정보에만 접근할 수 있다.

return 하면 public, 안한 것들은 private

return 해주는 함수 자체를 덮어쓰는 어뷰징을 막기위해서 동결시키는 방법 사용(Object.freeze())

### 부분 적용 함수

> 부분 적용 함수: n개의 인자를 받는 함수에 대해 미리 m개의 인자만 넘겨 기억시켰다가 나중에 n-m개를 받으면 비로소 원래 함수의 실행 결과를 얻을 수 있는 함수이다.(ex: 맨 처음 this 제외하면 bind()의 실행결과)

this 도 사용하려면 bind()를 사용하는 것은 메서드에서는 사용할 수 없다.
=> 비워놓음을 표시하기 위해 전역객체에 *를 준비하여 처음에 넘겨준 인자들 중 *로 구현된 공간마다 나중에 온 값들을 차례로 넣어주어 구현

일부 인자를 넘겨두어 기억하게끔 하고 추후 필요한 시점에 기억했던 인자들 까지 함께 실행한다.

모두 클로저를 핵심 기법으로 사용

#### 디바운스

> 디바운스: 짧은 시간동안 동일한 이벤트가 많이 발생할 경우 이를 전부 처리하지 않고 처음 또는 마지막에 발생한 이벤트에 대해 한번만 처리하는 것이다.
> ( 성능 최적화에 큰 도움 )

### 커링 함수

> 커링함수: 여러개의 인자를 받는 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출될 수 있게 체인 형태로 구성한 것을 말한다.

한번에 하나의 인자만 전달하는 것을 원칙으로 하며, 중간 과정상의 함수를 실행한 결과는 그 다음 인자를 받기 위해 대기만 할 뿐 마지막 인자가 전달될 때까지 원본함수가 실행되지 않는다.
(부분 적용 함수는 여러개의 인자를 전달할 수 있고, 실행 결과를 재실행할 때 원본함수가 무조건 실행된다.)

필요한 상황에 직접 만들어 쓰기 용이하다.=> 필요한 인자 개수만큼 함수를 만들고 계속 리턴하다가 마지막에 연산해서 리턴해주면 된다. 하지만 인자가 많아질 수록 가독성이 떨어진다.  
=> ES6에서의 화살표함수로 간단하게 표현 가능

받은 인자들이 모두 마지막 단계까지 GC되지 않고, 메모리에 쌓였다가 마지막 실행컨텍스트 종료 이후 한번에 GC로 수거된다.

커링함수는 마지막 인자가 넘어갈 때까지 함수 실행을 미루는 셈이된다.

---

## 2- depth

## Flux 아키텍처

### MVC의 한계

Flux 아키텍처란 FaceBook에서 개발한 단방향 데이터 흐름을 가지는 아키텍처이다.

![image](https://user-images.githubusercontent.com/49175629/167427767-cd878406-1eb8-45cb-a75c-1861b7ae05e6.png)

[출처](https://velog.io/@alskt0419/FLUX-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90%EB%9E%80)

Controller는 Model의 데이터를조회하거나 업데이트하고, Model은 이 데이터를 View를 통해 반영시킨다.
View는 사용자로부터 데이터를 입력받기도 하여 Model에 영향을 주기도 한다.

어플리케이션이 커지면 너무 복잡해져 새로운 기능을 추가할 때마다 문제가 발생한다. (코드 예측이나 테스트가 어렵고, 새로운 개발자가 와도 적응하는데 한참 걸림)

### 문제점

MVC의 근본적인 문제는 사용자와의 상호작용이 View에서 일어났기 때문에 사용자의 입력에 따라 Model을 업데이트 해줘야 하는 경우가 있고, 여기서 의존성의 이유로 하나의 모델이 아닌 여러개의 모델까지 업데이트 할 때가 있다.

![image](https://user-images.githubusercontent.com/49175629/167430612-e06351a6-7786-47f4-93cc-03ed2c69f89f.png)

## Flux 구조

![image](https://user-images.githubusercontent.com/49175629/167428591-f2f4bdcf-d570-4086-9a7c-cb5e6842f8a2.png)
[그림 출처](https://facebook.github.io/flux/docs/in-depth-overview.html#content)

가장 큰 특징은 단방향 데이터 흐름이다.

Action은 View에서 사용자가 취한 액션, Dispacher 는 중앙 통제소, Store는 View에 보여질 데이터를 모아놓는 저장소, View는 react 컴포넌트이다.

1. Action: state에 어떤 변화가 필요할 때 액션을 발생시킨다. (객체) Dispatcher 통해 스토어에 변화를 일으킬 수 있는데 이때 Dispatcher의 데이터 묶음
2. Dispatcher: Flux 어플리케이션의 모든 데이터 흐름을 관리한다.
3. Store: 애플리케이션의 상태를 저장
4. View: 상태를 가져와서 보여주고 사용자로 부터 입력 받을 화면을 보여줌

View에서 Action이 발생하면 Dispatcher는 해당 Action을 처리하기 위한 적절한 Store를 찾아서 전달한다.
Store는 이 요청을 처리하고, 데이터가 변화되었다고 감지하면 해당 View를 리렌더링한다.

![image](https://user-images.githubusercontent.com/49175629/167429093-f15b3474-87a5-4fea-93a7-5299cbcbc7ea.png)

[그림 출처](https://facebook.github.io/flux/docs/in-depth-overview.html#content)

## Redux

![image](https://user-images.githubusercontent.com/49175629/167432767-b936bc3e-d7ba-468b-8125-43f84e2b66ba.png)
[참고](https://www.youtube.com/watch?v=zw-Oz6oNjQE)

**상태를 컴포넌트가 가지지않고 스토어에서 관리하겠다.**

- 컴포넌트에서 앱 상태를 조작한다.(사용자 인터랙션)

- 스토어는 상태를 가지고, 이 상태를 컴포넌트는 지속적으로 구독(서브스크립션)을 해야한다. 업데이트가 되거나 프로퍼티가 전달되면 컴포넌트의 UI를 업데이트 해야한다.

- 상태변경을 dispatch(변경요청, action을 발생을 요청)

- 액션이 받아서 리듀서에 전달함.

- 리듀서는 (상태, 액션)을 두개를 받아서 처리해줌.

- 상태 업데이트 (하나 이상의 리듀서 결합가능)

- 스토어는 업데이트해서 컴포넌트가 구독하고 있는 서브스크립션에 트리거(방아쇠를 당겨)를 날려서 전달

- 서브스크립션에서 업데이트

- 구독하고 있던 컴포넌트는 상태 변경이 감지되면 리렌더링
